// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$Failure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() versionCheckFailure,
    required TResult Function() serverFailure,
    required TResult Function() dataParsingFailure,
    required TResult Function() noConnectionFailure,
    required TResult Function() notFoundFailure,
    required TResult Function() noUserDataFailure,
    required TResult Function() wrongTokenFailure,
    required TResult Function() wrongTextFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? versionCheckFailure,
    TResult? Function()? serverFailure,
    TResult? Function()? dataParsingFailure,
    TResult? Function()? noConnectionFailure,
    TResult? Function()? notFoundFailure,
    TResult? Function()? noUserDataFailure,
    TResult? Function()? wrongTokenFailure,
    TResult? Function()? wrongTextFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? versionCheckFailure,
    TResult Function()? serverFailure,
    TResult Function()? dataParsingFailure,
    TResult Function()? noConnectionFailure,
    TResult Function()? notFoundFailure,
    TResult Function()? noUserDataFailure,
    TResult Function()? wrongTokenFailure,
    TResult Function()? wrongTextFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VersionCheckFailure value) versionCheckFailure,
    required TResult Function(ServerFailure value) serverFailure,
    required TResult Function(DataParsingFailure value) dataParsingFailure,
    required TResult Function(NoConnectionFailure value) noConnectionFailure,
    required TResult Function(NotFoundFailure value) notFoundFailure,
    required TResult Function(NoUserDataFailure value) noUserDataFailure,
    required TResult Function(WrongTokenFailure value) wrongTokenFailure,
    required TResult Function(WrongTextFailure value) wrongTextFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(VersionCheckFailure value)? versionCheckFailure,
    TResult? Function(ServerFailure value)? serverFailure,
    TResult? Function(DataParsingFailure value)? dataParsingFailure,
    TResult? Function(NoConnectionFailure value)? noConnectionFailure,
    TResult? Function(NotFoundFailure value)? notFoundFailure,
    TResult? Function(NoUserDataFailure value)? noUserDataFailure,
    TResult? Function(WrongTokenFailure value)? wrongTokenFailure,
    TResult? Function(WrongTextFailure value)? wrongTextFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VersionCheckFailure value)? versionCheckFailure,
    TResult Function(ServerFailure value)? serverFailure,
    TResult Function(DataParsingFailure value)? dataParsingFailure,
    TResult Function(NoConnectionFailure value)? noConnectionFailure,
    TResult Function(NotFoundFailure value)? notFoundFailure,
    TResult Function(NoUserDataFailure value)? noUserDataFailure,
    TResult Function(WrongTokenFailure value)? wrongTokenFailure,
    TResult Function(WrongTextFailure value)? wrongTextFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FailureCopyWith<$Res> {
  factory $FailureCopyWith(Failure value, $Res Function(Failure) then) =
      _$FailureCopyWithImpl<$Res, Failure>;
}

/// @nodoc
class _$FailureCopyWithImpl<$Res, $Val extends Failure>
    implements $FailureCopyWith<$Res> {
  _$FailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$VersionCheckFailureCopyWith<$Res> {
  factory _$$VersionCheckFailureCopyWith(_$VersionCheckFailure value,
          $Res Function(_$VersionCheckFailure) then) =
      __$$VersionCheckFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$VersionCheckFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res, _$VersionCheckFailure>
    implements _$$VersionCheckFailureCopyWith<$Res> {
  __$$VersionCheckFailureCopyWithImpl(
      _$VersionCheckFailure _value, $Res Function(_$VersionCheckFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$VersionCheckFailure extends VersionCheckFailure {
  const _$VersionCheckFailure() : super._();

  @override
  String toString() {
    return 'Failure.versionCheckFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$VersionCheckFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() versionCheckFailure,
    required TResult Function() serverFailure,
    required TResult Function() dataParsingFailure,
    required TResult Function() noConnectionFailure,
    required TResult Function() notFoundFailure,
    required TResult Function() noUserDataFailure,
    required TResult Function() wrongTokenFailure,
    required TResult Function() wrongTextFailure,
  }) {
    return versionCheckFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? versionCheckFailure,
    TResult? Function()? serverFailure,
    TResult? Function()? dataParsingFailure,
    TResult? Function()? noConnectionFailure,
    TResult? Function()? notFoundFailure,
    TResult? Function()? noUserDataFailure,
    TResult? Function()? wrongTokenFailure,
    TResult? Function()? wrongTextFailure,
  }) {
    return versionCheckFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? versionCheckFailure,
    TResult Function()? serverFailure,
    TResult Function()? dataParsingFailure,
    TResult Function()? noConnectionFailure,
    TResult Function()? notFoundFailure,
    TResult Function()? noUserDataFailure,
    TResult Function()? wrongTokenFailure,
    TResult Function()? wrongTextFailure,
    required TResult orElse(),
  }) {
    if (versionCheckFailure != null) {
      return versionCheckFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VersionCheckFailure value) versionCheckFailure,
    required TResult Function(ServerFailure value) serverFailure,
    required TResult Function(DataParsingFailure value) dataParsingFailure,
    required TResult Function(NoConnectionFailure value) noConnectionFailure,
    required TResult Function(NotFoundFailure value) notFoundFailure,
    required TResult Function(NoUserDataFailure value) noUserDataFailure,
    required TResult Function(WrongTokenFailure value) wrongTokenFailure,
    required TResult Function(WrongTextFailure value) wrongTextFailure,
  }) {
    return versionCheckFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(VersionCheckFailure value)? versionCheckFailure,
    TResult? Function(ServerFailure value)? serverFailure,
    TResult? Function(DataParsingFailure value)? dataParsingFailure,
    TResult? Function(NoConnectionFailure value)? noConnectionFailure,
    TResult? Function(NotFoundFailure value)? notFoundFailure,
    TResult? Function(NoUserDataFailure value)? noUserDataFailure,
    TResult? Function(WrongTokenFailure value)? wrongTokenFailure,
    TResult? Function(WrongTextFailure value)? wrongTextFailure,
  }) {
    return versionCheckFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VersionCheckFailure value)? versionCheckFailure,
    TResult Function(ServerFailure value)? serverFailure,
    TResult Function(DataParsingFailure value)? dataParsingFailure,
    TResult Function(NoConnectionFailure value)? noConnectionFailure,
    TResult Function(NotFoundFailure value)? notFoundFailure,
    TResult Function(NoUserDataFailure value)? noUserDataFailure,
    TResult Function(WrongTokenFailure value)? wrongTokenFailure,
    TResult Function(WrongTextFailure value)? wrongTextFailure,
    required TResult orElse(),
  }) {
    if (versionCheckFailure != null) {
      return versionCheckFailure(this);
    }
    return orElse();
  }
}

abstract class VersionCheckFailure extends Failure {
  const factory VersionCheckFailure() = _$VersionCheckFailure;
  const VersionCheckFailure._() : super._();
}

/// @nodoc
abstract class _$$ServerFailureCopyWith<$Res> {
  factory _$$ServerFailureCopyWith(
          _$ServerFailure value, $Res Function(_$ServerFailure) then) =
      __$$ServerFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ServerFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res, _$ServerFailure>
    implements _$$ServerFailureCopyWith<$Res> {
  __$$ServerFailureCopyWithImpl(
      _$ServerFailure _value, $Res Function(_$ServerFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ServerFailure extends ServerFailure {
  const _$ServerFailure() : super._();

  @override
  String toString() {
    return 'Failure.serverFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ServerFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() versionCheckFailure,
    required TResult Function() serverFailure,
    required TResult Function() dataParsingFailure,
    required TResult Function() noConnectionFailure,
    required TResult Function() notFoundFailure,
    required TResult Function() noUserDataFailure,
    required TResult Function() wrongTokenFailure,
    required TResult Function() wrongTextFailure,
  }) {
    return serverFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? versionCheckFailure,
    TResult? Function()? serverFailure,
    TResult? Function()? dataParsingFailure,
    TResult? Function()? noConnectionFailure,
    TResult? Function()? notFoundFailure,
    TResult? Function()? noUserDataFailure,
    TResult? Function()? wrongTokenFailure,
    TResult? Function()? wrongTextFailure,
  }) {
    return serverFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? versionCheckFailure,
    TResult Function()? serverFailure,
    TResult Function()? dataParsingFailure,
    TResult Function()? noConnectionFailure,
    TResult Function()? notFoundFailure,
    TResult Function()? noUserDataFailure,
    TResult Function()? wrongTokenFailure,
    TResult Function()? wrongTextFailure,
    required TResult orElse(),
  }) {
    if (serverFailure != null) {
      return serverFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VersionCheckFailure value) versionCheckFailure,
    required TResult Function(ServerFailure value) serverFailure,
    required TResult Function(DataParsingFailure value) dataParsingFailure,
    required TResult Function(NoConnectionFailure value) noConnectionFailure,
    required TResult Function(NotFoundFailure value) notFoundFailure,
    required TResult Function(NoUserDataFailure value) noUserDataFailure,
    required TResult Function(WrongTokenFailure value) wrongTokenFailure,
    required TResult Function(WrongTextFailure value) wrongTextFailure,
  }) {
    return serverFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(VersionCheckFailure value)? versionCheckFailure,
    TResult? Function(ServerFailure value)? serverFailure,
    TResult? Function(DataParsingFailure value)? dataParsingFailure,
    TResult? Function(NoConnectionFailure value)? noConnectionFailure,
    TResult? Function(NotFoundFailure value)? notFoundFailure,
    TResult? Function(NoUserDataFailure value)? noUserDataFailure,
    TResult? Function(WrongTokenFailure value)? wrongTokenFailure,
    TResult? Function(WrongTextFailure value)? wrongTextFailure,
  }) {
    return serverFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VersionCheckFailure value)? versionCheckFailure,
    TResult Function(ServerFailure value)? serverFailure,
    TResult Function(DataParsingFailure value)? dataParsingFailure,
    TResult Function(NoConnectionFailure value)? noConnectionFailure,
    TResult Function(NotFoundFailure value)? notFoundFailure,
    TResult Function(NoUserDataFailure value)? noUserDataFailure,
    TResult Function(WrongTokenFailure value)? wrongTokenFailure,
    TResult Function(WrongTextFailure value)? wrongTextFailure,
    required TResult orElse(),
  }) {
    if (serverFailure != null) {
      return serverFailure(this);
    }
    return orElse();
  }
}

abstract class ServerFailure extends Failure {
  const factory ServerFailure() = _$ServerFailure;
  const ServerFailure._() : super._();
}

/// @nodoc
abstract class _$$DataParsingFailureCopyWith<$Res> {
  factory _$$DataParsingFailureCopyWith(_$DataParsingFailure value,
          $Res Function(_$DataParsingFailure) then) =
      __$$DataParsingFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataParsingFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res, _$DataParsingFailure>
    implements _$$DataParsingFailureCopyWith<$Res> {
  __$$DataParsingFailureCopyWithImpl(
      _$DataParsingFailure _value, $Res Function(_$DataParsingFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataParsingFailure extends DataParsingFailure {
  const _$DataParsingFailure() : super._();

  @override
  String toString() {
    return 'Failure.dataParsingFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataParsingFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() versionCheckFailure,
    required TResult Function() serverFailure,
    required TResult Function() dataParsingFailure,
    required TResult Function() noConnectionFailure,
    required TResult Function() notFoundFailure,
    required TResult Function() noUserDataFailure,
    required TResult Function() wrongTokenFailure,
    required TResult Function() wrongTextFailure,
  }) {
    return dataParsingFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? versionCheckFailure,
    TResult? Function()? serverFailure,
    TResult? Function()? dataParsingFailure,
    TResult? Function()? noConnectionFailure,
    TResult? Function()? notFoundFailure,
    TResult? Function()? noUserDataFailure,
    TResult? Function()? wrongTokenFailure,
    TResult? Function()? wrongTextFailure,
  }) {
    return dataParsingFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? versionCheckFailure,
    TResult Function()? serverFailure,
    TResult Function()? dataParsingFailure,
    TResult Function()? noConnectionFailure,
    TResult Function()? notFoundFailure,
    TResult Function()? noUserDataFailure,
    TResult Function()? wrongTokenFailure,
    TResult Function()? wrongTextFailure,
    required TResult orElse(),
  }) {
    if (dataParsingFailure != null) {
      return dataParsingFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VersionCheckFailure value) versionCheckFailure,
    required TResult Function(ServerFailure value) serverFailure,
    required TResult Function(DataParsingFailure value) dataParsingFailure,
    required TResult Function(NoConnectionFailure value) noConnectionFailure,
    required TResult Function(NotFoundFailure value) notFoundFailure,
    required TResult Function(NoUserDataFailure value) noUserDataFailure,
    required TResult Function(WrongTokenFailure value) wrongTokenFailure,
    required TResult Function(WrongTextFailure value) wrongTextFailure,
  }) {
    return dataParsingFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(VersionCheckFailure value)? versionCheckFailure,
    TResult? Function(ServerFailure value)? serverFailure,
    TResult? Function(DataParsingFailure value)? dataParsingFailure,
    TResult? Function(NoConnectionFailure value)? noConnectionFailure,
    TResult? Function(NotFoundFailure value)? notFoundFailure,
    TResult? Function(NoUserDataFailure value)? noUserDataFailure,
    TResult? Function(WrongTokenFailure value)? wrongTokenFailure,
    TResult? Function(WrongTextFailure value)? wrongTextFailure,
  }) {
    return dataParsingFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VersionCheckFailure value)? versionCheckFailure,
    TResult Function(ServerFailure value)? serverFailure,
    TResult Function(DataParsingFailure value)? dataParsingFailure,
    TResult Function(NoConnectionFailure value)? noConnectionFailure,
    TResult Function(NotFoundFailure value)? notFoundFailure,
    TResult Function(NoUserDataFailure value)? noUserDataFailure,
    TResult Function(WrongTokenFailure value)? wrongTokenFailure,
    TResult Function(WrongTextFailure value)? wrongTextFailure,
    required TResult orElse(),
  }) {
    if (dataParsingFailure != null) {
      return dataParsingFailure(this);
    }
    return orElse();
  }
}

abstract class DataParsingFailure extends Failure {
  const factory DataParsingFailure() = _$DataParsingFailure;
  const DataParsingFailure._() : super._();
}

/// @nodoc
abstract class _$$NoConnectionFailureCopyWith<$Res> {
  factory _$$NoConnectionFailureCopyWith(_$NoConnectionFailure value,
          $Res Function(_$NoConnectionFailure) then) =
      __$$NoConnectionFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoConnectionFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res, _$NoConnectionFailure>
    implements _$$NoConnectionFailureCopyWith<$Res> {
  __$$NoConnectionFailureCopyWithImpl(
      _$NoConnectionFailure _value, $Res Function(_$NoConnectionFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NoConnectionFailure extends NoConnectionFailure {
  const _$NoConnectionFailure() : super._();

  @override
  String toString() {
    return 'Failure.noConnectionFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NoConnectionFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() versionCheckFailure,
    required TResult Function() serverFailure,
    required TResult Function() dataParsingFailure,
    required TResult Function() noConnectionFailure,
    required TResult Function() notFoundFailure,
    required TResult Function() noUserDataFailure,
    required TResult Function() wrongTokenFailure,
    required TResult Function() wrongTextFailure,
  }) {
    return noConnectionFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? versionCheckFailure,
    TResult? Function()? serverFailure,
    TResult? Function()? dataParsingFailure,
    TResult? Function()? noConnectionFailure,
    TResult? Function()? notFoundFailure,
    TResult? Function()? noUserDataFailure,
    TResult? Function()? wrongTokenFailure,
    TResult? Function()? wrongTextFailure,
  }) {
    return noConnectionFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? versionCheckFailure,
    TResult Function()? serverFailure,
    TResult Function()? dataParsingFailure,
    TResult Function()? noConnectionFailure,
    TResult Function()? notFoundFailure,
    TResult Function()? noUserDataFailure,
    TResult Function()? wrongTokenFailure,
    TResult Function()? wrongTextFailure,
    required TResult orElse(),
  }) {
    if (noConnectionFailure != null) {
      return noConnectionFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VersionCheckFailure value) versionCheckFailure,
    required TResult Function(ServerFailure value) serverFailure,
    required TResult Function(DataParsingFailure value) dataParsingFailure,
    required TResult Function(NoConnectionFailure value) noConnectionFailure,
    required TResult Function(NotFoundFailure value) notFoundFailure,
    required TResult Function(NoUserDataFailure value) noUserDataFailure,
    required TResult Function(WrongTokenFailure value) wrongTokenFailure,
    required TResult Function(WrongTextFailure value) wrongTextFailure,
  }) {
    return noConnectionFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(VersionCheckFailure value)? versionCheckFailure,
    TResult? Function(ServerFailure value)? serverFailure,
    TResult? Function(DataParsingFailure value)? dataParsingFailure,
    TResult? Function(NoConnectionFailure value)? noConnectionFailure,
    TResult? Function(NotFoundFailure value)? notFoundFailure,
    TResult? Function(NoUserDataFailure value)? noUserDataFailure,
    TResult? Function(WrongTokenFailure value)? wrongTokenFailure,
    TResult? Function(WrongTextFailure value)? wrongTextFailure,
  }) {
    return noConnectionFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VersionCheckFailure value)? versionCheckFailure,
    TResult Function(ServerFailure value)? serverFailure,
    TResult Function(DataParsingFailure value)? dataParsingFailure,
    TResult Function(NoConnectionFailure value)? noConnectionFailure,
    TResult Function(NotFoundFailure value)? notFoundFailure,
    TResult Function(NoUserDataFailure value)? noUserDataFailure,
    TResult Function(WrongTokenFailure value)? wrongTokenFailure,
    TResult Function(WrongTextFailure value)? wrongTextFailure,
    required TResult orElse(),
  }) {
    if (noConnectionFailure != null) {
      return noConnectionFailure(this);
    }
    return orElse();
  }
}

abstract class NoConnectionFailure extends Failure {
  const factory NoConnectionFailure() = _$NoConnectionFailure;
  const NoConnectionFailure._() : super._();
}

/// @nodoc
abstract class _$$NotFoundFailureCopyWith<$Res> {
  factory _$$NotFoundFailureCopyWith(
          _$NotFoundFailure value, $Res Function(_$NotFoundFailure) then) =
      __$$NotFoundFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NotFoundFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res, _$NotFoundFailure>
    implements _$$NotFoundFailureCopyWith<$Res> {
  __$$NotFoundFailureCopyWithImpl(
      _$NotFoundFailure _value, $Res Function(_$NotFoundFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NotFoundFailure extends NotFoundFailure {
  const _$NotFoundFailure() : super._();

  @override
  String toString() {
    return 'Failure.notFoundFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NotFoundFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() versionCheckFailure,
    required TResult Function() serverFailure,
    required TResult Function() dataParsingFailure,
    required TResult Function() noConnectionFailure,
    required TResult Function() notFoundFailure,
    required TResult Function() noUserDataFailure,
    required TResult Function() wrongTokenFailure,
    required TResult Function() wrongTextFailure,
  }) {
    return notFoundFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? versionCheckFailure,
    TResult? Function()? serverFailure,
    TResult? Function()? dataParsingFailure,
    TResult? Function()? noConnectionFailure,
    TResult? Function()? notFoundFailure,
    TResult? Function()? noUserDataFailure,
    TResult? Function()? wrongTokenFailure,
    TResult? Function()? wrongTextFailure,
  }) {
    return notFoundFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? versionCheckFailure,
    TResult Function()? serverFailure,
    TResult Function()? dataParsingFailure,
    TResult Function()? noConnectionFailure,
    TResult Function()? notFoundFailure,
    TResult Function()? noUserDataFailure,
    TResult Function()? wrongTokenFailure,
    TResult Function()? wrongTextFailure,
    required TResult orElse(),
  }) {
    if (notFoundFailure != null) {
      return notFoundFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VersionCheckFailure value) versionCheckFailure,
    required TResult Function(ServerFailure value) serverFailure,
    required TResult Function(DataParsingFailure value) dataParsingFailure,
    required TResult Function(NoConnectionFailure value) noConnectionFailure,
    required TResult Function(NotFoundFailure value) notFoundFailure,
    required TResult Function(NoUserDataFailure value) noUserDataFailure,
    required TResult Function(WrongTokenFailure value) wrongTokenFailure,
    required TResult Function(WrongTextFailure value) wrongTextFailure,
  }) {
    return notFoundFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(VersionCheckFailure value)? versionCheckFailure,
    TResult? Function(ServerFailure value)? serverFailure,
    TResult? Function(DataParsingFailure value)? dataParsingFailure,
    TResult? Function(NoConnectionFailure value)? noConnectionFailure,
    TResult? Function(NotFoundFailure value)? notFoundFailure,
    TResult? Function(NoUserDataFailure value)? noUserDataFailure,
    TResult? Function(WrongTokenFailure value)? wrongTokenFailure,
    TResult? Function(WrongTextFailure value)? wrongTextFailure,
  }) {
    return notFoundFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VersionCheckFailure value)? versionCheckFailure,
    TResult Function(ServerFailure value)? serverFailure,
    TResult Function(DataParsingFailure value)? dataParsingFailure,
    TResult Function(NoConnectionFailure value)? noConnectionFailure,
    TResult Function(NotFoundFailure value)? notFoundFailure,
    TResult Function(NoUserDataFailure value)? noUserDataFailure,
    TResult Function(WrongTokenFailure value)? wrongTokenFailure,
    TResult Function(WrongTextFailure value)? wrongTextFailure,
    required TResult orElse(),
  }) {
    if (notFoundFailure != null) {
      return notFoundFailure(this);
    }
    return orElse();
  }
}

abstract class NotFoundFailure extends Failure {
  const factory NotFoundFailure() = _$NotFoundFailure;
  const NotFoundFailure._() : super._();
}

/// @nodoc
abstract class _$$NoUserDataFailureCopyWith<$Res> {
  factory _$$NoUserDataFailureCopyWith(
          _$NoUserDataFailure value, $Res Function(_$NoUserDataFailure) then) =
      __$$NoUserDataFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoUserDataFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res, _$NoUserDataFailure>
    implements _$$NoUserDataFailureCopyWith<$Res> {
  __$$NoUserDataFailureCopyWithImpl(
      _$NoUserDataFailure _value, $Res Function(_$NoUserDataFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NoUserDataFailure extends NoUserDataFailure {
  const _$NoUserDataFailure() : super._();

  @override
  String toString() {
    return 'Failure.noUserDataFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NoUserDataFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() versionCheckFailure,
    required TResult Function() serverFailure,
    required TResult Function() dataParsingFailure,
    required TResult Function() noConnectionFailure,
    required TResult Function() notFoundFailure,
    required TResult Function() noUserDataFailure,
    required TResult Function() wrongTokenFailure,
    required TResult Function() wrongTextFailure,
  }) {
    return noUserDataFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? versionCheckFailure,
    TResult? Function()? serverFailure,
    TResult? Function()? dataParsingFailure,
    TResult? Function()? noConnectionFailure,
    TResult? Function()? notFoundFailure,
    TResult? Function()? noUserDataFailure,
    TResult? Function()? wrongTokenFailure,
    TResult? Function()? wrongTextFailure,
  }) {
    return noUserDataFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? versionCheckFailure,
    TResult Function()? serverFailure,
    TResult Function()? dataParsingFailure,
    TResult Function()? noConnectionFailure,
    TResult Function()? notFoundFailure,
    TResult Function()? noUserDataFailure,
    TResult Function()? wrongTokenFailure,
    TResult Function()? wrongTextFailure,
    required TResult orElse(),
  }) {
    if (noUserDataFailure != null) {
      return noUserDataFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VersionCheckFailure value) versionCheckFailure,
    required TResult Function(ServerFailure value) serverFailure,
    required TResult Function(DataParsingFailure value) dataParsingFailure,
    required TResult Function(NoConnectionFailure value) noConnectionFailure,
    required TResult Function(NotFoundFailure value) notFoundFailure,
    required TResult Function(NoUserDataFailure value) noUserDataFailure,
    required TResult Function(WrongTokenFailure value) wrongTokenFailure,
    required TResult Function(WrongTextFailure value) wrongTextFailure,
  }) {
    return noUserDataFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(VersionCheckFailure value)? versionCheckFailure,
    TResult? Function(ServerFailure value)? serverFailure,
    TResult? Function(DataParsingFailure value)? dataParsingFailure,
    TResult? Function(NoConnectionFailure value)? noConnectionFailure,
    TResult? Function(NotFoundFailure value)? notFoundFailure,
    TResult? Function(NoUserDataFailure value)? noUserDataFailure,
    TResult? Function(WrongTokenFailure value)? wrongTokenFailure,
    TResult? Function(WrongTextFailure value)? wrongTextFailure,
  }) {
    return noUserDataFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VersionCheckFailure value)? versionCheckFailure,
    TResult Function(ServerFailure value)? serverFailure,
    TResult Function(DataParsingFailure value)? dataParsingFailure,
    TResult Function(NoConnectionFailure value)? noConnectionFailure,
    TResult Function(NotFoundFailure value)? notFoundFailure,
    TResult Function(NoUserDataFailure value)? noUserDataFailure,
    TResult Function(WrongTokenFailure value)? wrongTokenFailure,
    TResult Function(WrongTextFailure value)? wrongTextFailure,
    required TResult orElse(),
  }) {
    if (noUserDataFailure != null) {
      return noUserDataFailure(this);
    }
    return orElse();
  }
}

abstract class NoUserDataFailure extends Failure {
  const factory NoUserDataFailure() = _$NoUserDataFailure;
  const NoUserDataFailure._() : super._();
}

/// @nodoc
abstract class _$$WrongTokenFailureCopyWith<$Res> {
  factory _$$WrongTokenFailureCopyWith(
          _$WrongTokenFailure value, $Res Function(_$WrongTokenFailure) then) =
      __$$WrongTokenFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WrongTokenFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res, _$WrongTokenFailure>
    implements _$$WrongTokenFailureCopyWith<$Res> {
  __$$WrongTokenFailureCopyWithImpl(
      _$WrongTokenFailure _value, $Res Function(_$WrongTokenFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WrongTokenFailure extends WrongTokenFailure {
  const _$WrongTokenFailure() : super._();

  @override
  String toString() {
    return 'Failure.wrongTokenFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WrongTokenFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() versionCheckFailure,
    required TResult Function() serverFailure,
    required TResult Function() dataParsingFailure,
    required TResult Function() noConnectionFailure,
    required TResult Function() notFoundFailure,
    required TResult Function() noUserDataFailure,
    required TResult Function() wrongTokenFailure,
    required TResult Function() wrongTextFailure,
  }) {
    return wrongTokenFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? versionCheckFailure,
    TResult? Function()? serverFailure,
    TResult? Function()? dataParsingFailure,
    TResult? Function()? noConnectionFailure,
    TResult? Function()? notFoundFailure,
    TResult? Function()? noUserDataFailure,
    TResult? Function()? wrongTokenFailure,
    TResult? Function()? wrongTextFailure,
  }) {
    return wrongTokenFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? versionCheckFailure,
    TResult Function()? serverFailure,
    TResult Function()? dataParsingFailure,
    TResult Function()? noConnectionFailure,
    TResult Function()? notFoundFailure,
    TResult Function()? noUserDataFailure,
    TResult Function()? wrongTokenFailure,
    TResult Function()? wrongTextFailure,
    required TResult orElse(),
  }) {
    if (wrongTokenFailure != null) {
      return wrongTokenFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VersionCheckFailure value) versionCheckFailure,
    required TResult Function(ServerFailure value) serverFailure,
    required TResult Function(DataParsingFailure value) dataParsingFailure,
    required TResult Function(NoConnectionFailure value) noConnectionFailure,
    required TResult Function(NotFoundFailure value) notFoundFailure,
    required TResult Function(NoUserDataFailure value) noUserDataFailure,
    required TResult Function(WrongTokenFailure value) wrongTokenFailure,
    required TResult Function(WrongTextFailure value) wrongTextFailure,
  }) {
    return wrongTokenFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(VersionCheckFailure value)? versionCheckFailure,
    TResult? Function(ServerFailure value)? serverFailure,
    TResult? Function(DataParsingFailure value)? dataParsingFailure,
    TResult? Function(NoConnectionFailure value)? noConnectionFailure,
    TResult? Function(NotFoundFailure value)? notFoundFailure,
    TResult? Function(NoUserDataFailure value)? noUserDataFailure,
    TResult? Function(WrongTokenFailure value)? wrongTokenFailure,
    TResult? Function(WrongTextFailure value)? wrongTextFailure,
  }) {
    return wrongTokenFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VersionCheckFailure value)? versionCheckFailure,
    TResult Function(ServerFailure value)? serverFailure,
    TResult Function(DataParsingFailure value)? dataParsingFailure,
    TResult Function(NoConnectionFailure value)? noConnectionFailure,
    TResult Function(NotFoundFailure value)? notFoundFailure,
    TResult Function(NoUserDataFailure value)? noUserDataFailure,
    TResult Function(WrongTokenFailure value)? wrongTokenFailure,
    TResult Function(WrongTextFailure value)? wrongTextFailure,
    required TResult orElse(),
  }) {
    if (wrongTokenFailure != null) {
      return wrongTokenFailure(this);
    }
    return orElse();
  }
}

abstract class WrongTokenFailure extends Failure {
  const factory WrongTokenFailure() = _$WrongTokenFailure;
  const WrongTokenFailure._() : super._();
}

/// @nodoc
abstract class _$$WrongTextFailureCopyWith<$Res> {
  factory _$$WrongTextFailureCopyWith(
          _$WrongTextFailure value, $Res Function(_$WrongTextFailure) then) =
      __$$WrongTextFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WrongTextFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res, _$WrongTextFailure>
    implements _$$WrongTextFailureCopyWith<$Res> {
  __$$WrongTextFailureCopyWithImpl(
      _$WrongTextFailure _value, $Res Function(_$WrongTextFailure) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WrongTextFailure extends WrongTextFailure {
  const _$WrongTextFailure() : super._();

  @override
  String toString() {
    return 'Failure.wrongTextFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WrongTextFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() versionCheckFailure,
    required TResult Function() serverFailure,
    required TResult Function() dataParsingFailure,
    required TResult Function() noConnectionFailure,
    required TResult Function() notFoundFailure,
    required TResult Function() noUserDataFailure,
    required TResult Function() wrongTokenFailure,
    required TResult Function() wrongTextFailure,
  }) {
    return wrongTextFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? versionCheckFailure,
    TResult? Function()? serverFailure,
    TResult? Function()? dataParsingFailure,
    TResult? Function()? noConnectionFailure,
    TResult? Function()? notFoundFailure,
    TResult? Function()? noUserDataFailure,
    TResult? Function()? wrongTokenFailure,
    TResult? Function()? wrongTextFailure,
  }) {
    return wrongTextFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? versionCheckFailure,
    TResult Function()? serverFailure,
    TResult Function()? dataParsingFailure,
    TResult Function()? noConnectionFailure,
    TResult Function()? notFoundFailure,
    TResult Function()? noUserDataFailure,
    TResult Function()? wrongTokenFailure,
    TResult Function()? wrongTextFailure,
    required TResult orElse(),
  }) {
    if (wrongTextFailure != null) {
      return wrongTextFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(VersionCheckFailure value) versionCheckFailure,
    required TResult Function(ServerFailure value) serverFailure,
    required TResult Function(DataParsingFailure value) dataParsingFailure,
    required TResult Function(NoConnectionFailure value) noConnectionFailure,
    required TResult Function(NotFoundFailure value) notFoundFailure,
    required TResult Function(NoUserDataFailure value) noUserDataFailure,
    required TResult Function(WrongTokenFailure value) wrongTokenFailure,
    required TResult Function(WrongTextFailure value) wrongTextFailure,
  }) {
    return wrongTextFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(VersionCheckFailure value)? versionCheckFailure,
    TResult? Function(ServerFailure value)? serverFailure,
    TResult? Function(DataParsingFailure value)? dataParsingFailure,
    TResult? Function(NoConnectionFailure value)? noConnectionFailure,
    TResult? Function(NotFoundFailure value)? notFoundFailure,
    TResult? Function(NoUserDataFailure value)? noUserDataFailure,
    TResult? Function(WrongTokenFailure value)? wrongTokenFailure,
    TResult? Function(WrongTextFailure value)? wrongTextFailure,
  }) {
    return wrongTextFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(VersionCheckFailure value)? versionCheckFailure,
    TResult Function(ServerFailure value)? serverFailure,
    TResult Function(DataParsingFailure value)? dataParsingFailure,
    TResult Function(NoConnectionFailure value)? noConnectionFailure,
    TResult Function(NotFoundFailure value)? notFoundFailure,
    TResult Function(NoUserDataFailure value)? noUserDataFailure,
    TResult Function(WrongTokenFailure value)? wrongTokenFailure,
    TResult Function(WrongTextFailure value)? wrongTextFailure,
    required TResult orElse(),
  }) {
    if (wrongTextFailure != null) {
      return wrongTextFailure(this);
    }
    return orElse();
  }
}

abstract class WrongTextFailure extends Failure {
  const factory WrongTextFailure() = _$WrongTextFailure;
  const WrongTextFailure._() : super._();
}
